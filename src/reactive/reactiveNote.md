## reactive 笔记

### 	1、 vue2 和vue3 实现响应式数据的原理区别

​			vue2中是利用原生js 下的Object.defineProperty()进行数据劫持
​           再通过里面的getter和setter方法进行数据的查看和修改，通过发布、订阅者模式进行数据与视图的响应式。


####    vue2响应式的缺点：
    1、不能监听对象的新增属性和删除属性
    2、无法正确监听数组的方法       


#### vue3响应式数据的原理：

```
1、对于基本的数据类型：
	依然是靠Object.defineProperty() 的get和set来完成
2、对于对象类型的数据：
	通过Proxy代理：拦截对象中任意属性的变化，包括属性值的读写、添加、删除等操作
	通过Reflect反射函数进行操作
```

#### Proxy特点

```
1、代理的对象是不等于原始数据对象
2、原始对象里头的数据和被Proxy包装的对象之间是有关联的。即当原始对象里头数据发生改变时，会影响代理对象；代理对象里头的数据发生变化对应的原始数据也会发生变化。
```

### 重要函数：

#### effect（副作用函数）：

```
targetMap用于存储副作用，并建立副作用和依赖的对应关系。
通俗理解就是将响应式对象和依赖其的函数联系起来

一个副作用可能依赖多个响应式对象，一个响应式对象里可能依赖多个属性
而同一个属性又可能被多个副作用依赖
```

#### track：



#### trigger：

```
触发函数，会遍历我们存的每一个effect，然后运行它们
```



#### 使用反射和代理去添加属性有什么好处

```
当我们使用代理的时候，所谓的响应式转换会变成懒加载；
在Vue2中，当我们进行转换的时候，我们必须尽快完成转换，因为当你将对象传递给Vue2的响应式，我们必须遍历所有的键并当场转换。以后当他们被访问时，它们已经被转换了；
但是对于Vue3，当你调用reactive时，对于一个对象，我们所做的就是返回一个代理对象，仅在需要转换时嵌套对象(当你需要访问它的时候)，这就类似于懒加载；
这样，如果你的app有一个庞大的对象列表，但是对于分页，你只是渲染页面的前面10个，也就是只有前面10个必须经过响应式转换，可以为启动应用程序来说节省许多的时间；
```

